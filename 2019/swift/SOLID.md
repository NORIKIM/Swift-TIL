# SOLID

### S  (Single Responsibility Principle) 단일 책임 원칙

클래스는 응집도 있는 하나의 책임만 가져야 한다 = 클래스를 수정할 이유는 오직 응집도여야한다

(책임 = knowing 과 doing)

### O  (Open Closed Principle) 개방폐쇄 원칙

소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

어떤 추가 혹은 수정이 필요할 때 코드 변화가 최소화 되야한다.

(프로토콜, 익스텐션 등을 이용하면 유연한 코드를 작성하기 수월하다. => 핵심 접근 방식은 추상화)

### L  (Liskov Substitusion Principle) 리스코프 치환 원칙

프로그램의 객체는 프로그램의 정확성을 깨뜨리지 앟으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

서브타입(상속받은) 기본 타입으로 대체 가능해야 한다. 자식 클래스는 부모 클래스 동작(의미)를 바꾸지 않는다.( = 부모클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다는 것)

```
이해를 돕기위해 도형을 예시를 들어보자. 도형 클래스와 사각형 클래스가 있고, 사각형 클래스는 도형 클래스의 상속을 받는다고 가정하자.
(1) 도형은 둘레를 가지고 있다.
(2) 도형은 넓이를 가지고 있다.
(3) 도형은 각을 가지고 있다.
일반화 관계(일관성인지 확인하는 방법은 단어를 교체해 보면 알 수 있다.  (1) ~ (3)의 도형이란 단어 대신 사각형을 넣어보자.
(1) 사각형은 둘레를 가지고 있다.
(2) 사각형은 넓이를 가지고 있다.
(3) 사각형은 각을 가지고 있다.
(1) ~ (3) 모두 딱히 이상한 부분이 보이지 않는다. 따라서 도형과 사각형 사이에는 일관성이 있다고 할 수 있다.
여기서 원(Circle) 이라는 도형에 대해 생각해보자. 원 클래스 역시 도형 클래스의 상속을 받는다고 가정하자. 앞에서 언급한 (1) ~ (3)의 도형 단어 대신 원을 대입해보자.
(1) 원은 둘레를 가지고 있다.
(2) 원은 넓이를 가지고 있다.
(3) 원은 각을 가지고 있다.
문장을 읽어보면 (3)번 문장이 어색하다는 것을 알 수 있다. 따라서 도형 클래스는 LSP을 만족하지 않은 설계라 할 수 있다. 따라서 (3)문장에 대해서는 일반화 관계가 성립하도록 수정되어야 한다.
```

### I  (Interface Segregation Principle) 인터페이스 분리 원칙

클라이언트 객체는 사용하지 않는 메소드에 의존하면 안된다.

한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스 보다 여러 개의 구체적인 인터페이스가 낫다. = 자신이 사용하지 않는 기능(인터페이스)에는 영향을 받지 말아야 한다. 

(인터페이스에 대한 SRP 라고 할 수 있다 : 인터페이스가 거대해 지는 상황에는 SRP원칙이 깨지는 상황이 생기므로 인터페이스를 분리해라 / NSCoding, NSploxy같은 것들은 구현체가 없고 형태만 있다 => 프로토콜로 구현됨.)

예> 스마트폰으로 전화 중일 때는 웹서핑,사진촬영 등 다른 기능은 사용하지 않는다. 따라서 전화 기능과 웹서핑, 사진촬영 기능은 각각 독립된 인퍼테이스로 구현하여 서로에게 영향을 받지 않도록 설계해야 한다. 이렇게 설계된 소프트웨어는 인터페이스 분리 원칙을 통해 시스템의 내부 의존성을 약화시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있다.

### D  (Dependency Inversion Principle) 의존관계 역전 원칙

추상화는 구체화에 의존하면 안되고, 구체화는 추상화에 의존하면 안된다. 

상위클래스는 하위클래스에 의존해서는 안된다.( = 둘다 추상화된 인터페이스에 의존해야한다.)

참고 및 출처 : https://wkdtjsgur100.github.io/solid-principle/



객체지향 5원칙!

프로그래머가 소스코드를 읽기 쉽고 확장하기 쉬워질 때까지 리펙토링하는 것.(문제가 발생할 가능성을 줄이는 것)

결합도는 낮게 하고 응집도는 높아야 한다

​    결합도: 다른 모듈이나 클래스의 의존도

​    응집도: 하나의 클래스의 코드들이 관련이 깊은지

시간이 지나도 유지보수가 쉽고 재사용이 가능하고 생산성을 위해서 사용하는 원칙이다.

**어떠한 객체의 수정이 필요할 때 기존의 함수나 클래스를 수정하는 것이 아니라 대체할 수 있어야 하는것**

==>> 코드는 유연하게 작성하자 = 클래스의 메소드의 의존성을 낮추는 것 , 추후 수정이 필요한 코드가 있다고 생각하면서 작성해야한다



### SOLID원칙을 준수하여 작성한 예제

https://github.com/godrm/ChessMate

Master Branch : 고치기 전 / Review Branch : 고친 후



**객체와 속성을 분리하고 분류하는 연습을 많이 해봐야 한다. 코드로 구현하기 전에 *CRC카드를 작성하여 이 객체의 knowing과 doing을 명확히 정리하면 더 깔끔하고 유연한 코드 작성에 좋다**

- 객체 속성을 가져오지 말고 객체가 일하도록 시켜야 한다.

- 상위 객체는 여러 하위 객체를 포함 할 수 있다.

- 상위 객체가 포함하는 하위 객체끼리 협력하고, 하위 객체 추상화 수준은 동일해야 한다.

**CRC카드**

클래스, 책임, 협력을 표현하는 카드

- 책임
  1. 알아야 하는 것들(대부분 값=프로퍼티) 
  2. 해야하는 것들(기능적인 측면=메소드)

- 협력 : 책임이 알아야 하는 다른 외부 객체들

단, 가능한 input과 output은 제외한다

<img width="300" src="https://user-images.githubusercontent.com/31604976/57840678-0cb68000-7804-11e9-9087-91a211cf2122.jpeg">